"
I am an inline block generated by inline splitter, to parse inline text.

I am characterized by:
- start & end: locations of my opener & closer delimiters in initial string
- substring: concerned text (without delimiters so)
- kind: my type, symbol which must be the same than my relative delimiter type (#basic for normal text)
- children: array in case of nested inline blocks


"
Class {
	#name : #MicInlineElement2,
	#superclass : #MicElement,
	#instVars : [
		'substring',
		'children'
	],
	#category : #'Microdown-InlineParser'
}

{ #category : #testing }
MicInlineElement2 class >> isEvaluated [
	^ true
]

{ #category : #parsing }
MicInlineElement2 class >> parse: token stream: aTokenStream for: aParser [
	^ aParser parseEvaluatedBlock: self token: token stream: aTokenStream
]

{ #category : #visiting }
MicInlineElement2 >> accept: dummy [
	"implemented in subclasses"
]

{ #category : #accessing }
MicInlineElement2 >> children [

	^ children
]

{ #category : #accessing }
MicInlineElement2 >> children: anObject [

	children := anObject
]

{ #category : #printing }
MicInlineElement2 >> childrenPrintOn [
	^ (children asString allButFirst: 9) allButLast
]

{ #category : #visiting }
MicInlineElement2 >> closeMe [
	"use for post parsing initialization"
]

{ #category : #initialization }
MicInlineElement2 >> initialize [
	children := #().
	substring := ''
]

{ #category : #private }
MicInlineElement2 >> inlineParserClass [

	^ MicInlineParser2
]

{ #category : #accessing }
MicInlineElement2 >> kind [
	"return a small string name used for printing and testing"
	^ { MicAnchorReferenceBlock2 -> #anchorReference.
	MicMathInlineBlock2 -> #math.
	MicRawBlock2 -> #raw.
	MicTextBlock2 -> #basic.
	MicBoldFormatBlock2 -> #bold.
	MicItalicFormatBlock2 -> #italic.
	MicMonospaceFormatBlock2 -> #monospace.
	MicStrikeFormatBlock2 -> #strike.
	MicFigureBlock2 -> #figure.
	MicLinkBlock2 -> #linkName } asDictionary at: self
]

{ #category : #printing }
MicInlineElement2 >> print: aString surroundedOn: aStream [

	aStream 
		nextPut: $(;
		nextPutAll: aString;
		nextPut: $) 

]

{ #category : #printing }
MicInlineElement2 >> printOn: aStream [

	| contents |
	contents := children 
		ifEmpty: [ self substring ] 
		ifNotEmpty: [ self childrenPrintOn ].
	aStream nextPut: $[;
				nextPutAll: contents;
				nextPut: $];
				nextPut: $(;
				nextPutAll: self kind;
				nextPut: $) 

]

{ #category : #printing }
MicInlineElement2 >> printWithoutConventions: aStream [
	"Remove Mic and Block from the class."
	
	aStream nextPutAll: ((self class name allButFirst: 3) allButLast: 5).

]

{ #category : #accessing }
MicInlineElement2 >> substring [

	^ substring
]

{ #category : #accessing }
MicInlineElement2 >> substring: anObject [

	substring := anObject
]
